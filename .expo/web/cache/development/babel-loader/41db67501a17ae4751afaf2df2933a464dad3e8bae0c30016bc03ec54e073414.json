{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { setLogLevel as _setLogLevel, connectFirestoreEmulator, initializeFirestore, runTransaction, getApp, getFirestore, collection, collectionGroup, doc, getDoc, getDocs, getCount, getAggregate, count, average, sum, deleteDoc, setDoc, updateDoc, writeBatch, terminate as _terminate } from '@react-native-firebase/app/lib/internal/web/firebaseFirestore';\nimport { guard, getWebError, emitEvent } from '@react-native-firebase/app/lib/internal/web/utils';\nimport { objectToWriteable, readableToObject, parseDocumentBatches } from \"./convert\";\nimport { buildQuery } from \"./query\";\nfunction rejectWithCodeAndMessage(code, message) {\n  return Promise.reject(getWebError({\n    code: code,\n    message: message\n  }));\n}\nfunction documentSnapshotToObject(snapshot) {\n  var exists = snapshot.exists();\n  var out = {\n    metadata: [false, false],\n    path: snapshot.ref.path,\n    exists: exists\n  };\n  if (exists) {\n    out.data = objectToWriteable(snapshot.data() || {});\n  }\n  return out;\n}\nfunction querySnapshotToObject(snapshot) {\n  return {\n    source: 'get',\n    excludesMetadataChanges: true,\n    changes: [],\n    metadata: [false, false],\n    documents: snapshot.docs.map(documentSnapshotToObject)\n  };\n}\nvar emulatorForApp = {};\nvar firestoreInstances = {};\nvar appInstances = {};\nvar transactionHandler = {};\nvar transactionBuffer = {};\nfunction getCachedAppInstance(appName) {\n  return appInstances[appName] ??= getApp(appName);\n}\nfunction createFirestoreKey(appName, databaseId) {\n  return `${appName}:${databaseId}`;\n}\nfunction getCachedFirestoreInstance(appName, databaseId) {\n  var firestoreKey = createFirestoreKey(appName, databaseId);\n  var instance = firestoreInstances[firestoreKey];\n  if (!instance) {\n    instance = getFirestore(getCachedAppInstance(appName), databaseId);\n    if (emulatorForApp[firestoreKey]) {\n      connectFirestoreEmulator(instance, emulatorForApp[firestoreKey].host, emulatorForApp[firestoreKey].port);\n    }\n    firestoreInstances[firestoreKey] = instance;\n  }\n  return instance;\n}\nexport default {\n  setLogLevel: function () {\n    var _setLogLevel2 = _asyncToGenerator(function* (logLevel) {\n      if (logLevel === 'debug' || logLevel === 'error') {\n        _setLogLevel(logLevel);\n      } else {\n        _setLogLevel('silent');\n      }\n    });\n    function setLogLevel(_x) {\n      return _setLogLevel2.apply(this, arguments);\n    }\n    return setLogLevel;\n  }(),\n  loadBundle: function loadBundle() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  clearPersistence: function clearPersistence() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  waitForPendingWrites: function () {\n    var _waitForPendingWrites = _asyncToGenerator(function* () {\n      return null;\n    });\n    function waitForPendingWrites() {\n      return _waitForPendingWrites.apply(this, arguments);\n    }\n    return waitForPendingWrites;\n  }(),\n  disableNetwork: function disableNetwork() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  enableNetwork: function enableNetwork() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  addSnapshotsInSync: function addSnapshotsInSync() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  removeSnapshotsInSync: function removeSnapshotsInSync() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  useEmulator: function useEmulator(appName, databaseId, host, port) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      connectFirestoreEmulator(firestore, host, port);\n      var firestoreKey = createFirestoreKey(appName, databaseId);\n      emulatorForApp[firestoreKey] = {\n        host: host,\n        port: port\n      };\n    }));\n  },\n  settings: function settings(appName, databaseId, _settings) {\n    return guard(function () {\n      var instance = initializeFirestore(getCachedAppInstance(appName), _settings, databaseId);\n      firestoreInstances[appName] = instance;\n    });\n  },\n  terminate: function terminate(appName, databaseId) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      yield _terminate(firestore);\n      return null;\n    }));\n  },\n  namedQueryOnSnapshot: function namedQueryOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  collectionOnSnapshot: function collectionOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  collectionOffSnapshot: function collectionOffSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  namedQueryGet: function namedQueryGet() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  collectionCount: function collectionCount(appName, databaseId, path, type, filters, orders, options) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var queryRef = type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      var query = buildQuery(queryRef, filters, orders, options);\n      var snapshot = yield getCount(query);\n      return {\n        count: snapshot.data().count\n      };\n    }));\n  },\n  aggregateQuery: function aggregateQuery(appName, databaseId, path, type, filters, orders, options, aggregateQueries) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var queryRef = type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      var query = buildQuery(queryRef, filters, orders, options);\n      var aggregateSpec = {};\n      for (var i = 0; i < aggregateQueries.length; i++) {\n        var aggregateQuery = aggregateQueries[i];\n        var aggregateType = aggregateQuery.aggregateType,\n          field = aggregateQuery.field,\n          key = aggregateQuery.key;\n        switch (aggregateType) {\n          case 'count':\n            aggregateSpec[key] = count();\n            break;\n          case 'average':\n            aggregateSpec[key] = average(field);\n            break;\n          case 'sum':\n            aggregateSpec[key] = sum(field);\n            break;\n        }\n      }\n      var result = yield getAggregate(query, aggregateSpec);\n      var data = result.data();\n      var response = {};\n      for (var _i = 0; _i < aggregateQueries.length; _i++) {\n        var _aggregateQuery = aggregateQueries[_i];\n        var _key = _aggregateQuery.key;\n        response[_key] = data[_key];\n      }\n      return response;\n    }));\n  },\n  collectionGet: function collectionGet(appName, databaseId, path, type, filters, orders, options, getOptions) {\n    if (getOptions && getOptions.source === 'cache') {\n      return rejectWithCodeAndMessage('unsupported', 'The source cache is not supported in the lite SDK.');\n    }\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var queryRef = type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      var query = buildQuery(queryRef, filters, orders, options);\n      var snapshot = yield getDocs(query);\n      return querySnapshotToObject(snapshot);\n    }));\n  },\n  documentOnSnapshot: function documentOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  documentOffSnapshot: function documentOffSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  persistenceCacheIndexManager: function persistenceCacheIndexManager() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  documentGet: function documentGet(appName, databaseId, path, getOptions) {\n    return guard(_asyncToGenerator(function* () {\n      if (getOptions && getOptions.source === 'cache') {\n        return rejectWithCodeAndMessage('unsupported', 'The source cache is not supported in the lite SDK.');\n      }\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var ref = doc(firestore, path);\n      var snapshot = yield getDoc(ref);\n      return documentSnapshotToObject(snapshot);\n    }));\n  },\n  documentDelete: function documentDelete(appName, databaseId, path) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var ref = doc(firestore, path);\n      yield deleteDoc(ref);\n      return null;\n    }));\n  },\n  documentSet: function documentSet(appName, databaseId, path, data, options) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var ref = doc(firestore, path);\n      var setOptions = {};\n      if ('merge' in options) {\n        setOptions.merge = options.merge;\n      } else if ('mergeFields' in options) {\n        setOptions.mergeFields = options.mergeFields;\n      }\n      yield setDoc(ref, readableToObject(firestore, data), setOptions);\n    }));\n  },\n  documentUpdate: function documentUpdate(appName, databaseId, path, data) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var ref = doc(firestore, path);\n      yield updateDoc(ref, readableToObject(firestore, data));\n    }));\n  },\n  documentBatch: function documentBatch(appName, databaseId, writes) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var batch = writeBatch(firestore);\n      var writesArray = parseDocumentBatches(firestore, writes);\n      for (var parsed of writesArray) {\n        var type = parsed.type,\n          path = parsed.path;\n        var ref = doc(firestore, path);\n        switch (type) {\n          case 'DELETE':\n            batch.delete(ref);\n            break;\n          case 'UPDATE':\n            batch.update(ref, parsed.data);\n            break;\n          case 'SET':\n            var options = parsed.options;\n            var setOptions = {};\n            if ('merge' in options) {\n              setOptions.merge = options.merge;\n            } else if ('mergeFields' in options) {\n              setOptions.mergeFields = options.mergeFields;\n            }\n            batch.set(ref, parsed.data, setOptions);\n            break;\n        }\n      }\n      yield batch.commit();\n    }));\n  },\n  transactionGetDocument: function transactionGetDocument(appName, databaseId, transactionId, path) {\n    if (!transactionHandler[transactionId]) {\n      return rejectWithCodeAndMessage('internal-error', 'An internal error occurred whilst attempting to find a native transaction by id.');\n    }\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var docRef = doc(firestore, path);\n      var tsx = transactionHandler[transactionId];\n      var snapshot = yield tsx.get(docRef);\n      return documentSnapshotToObject(snapshot);\n    }));\n  },\n  transactionDispose: function transactionDispose(_appName, _databaseId, transactionId) {\n    delete transactionHandler[transactionId];\n  },\n  transactionApplyBuffer: function transactionApplyBuffer(_appName, _databaseId, transactionId, commandBuffer) {\n    if (transactionHandler[transactionId]) {\n      transactionBuffer[transactionId] = commandBuffer;\n    }\n  },\n  transactionBegin: function transactionBegin(appName, databaseId, transactionId) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      try {\n        yield runTransaction(firestore, function () {\n          var _ref11 = _asyncToGenerator(function* (tsx) {\n            transactionHandler[transactionId] = tsx;\n            emitEvent('firestore_transaction_event', {\n              eventName: 'firestore_transaction_event',\n              body: {\n                type: 'update'\n              },\n              appName: appName,\n              databaseId: databaseId,\n              listenerId: transactionId\n            });\n            function getBuffer() {\n              return transactionBuffer[transactionId];\n            }\n            var buffer = yield new Promise(function (resolve) {\n              var interval = setInterval(function () {\n                var buffer = getBuffer();\n                if (buffer) {\n                  clearInterval(interval);\n                  resolve(buffer);\n                }\n              }, 100);\n            });\n            for (var serialized of buffer) {\n              var path = serialized.path,\n                type = serialized.type,\n                data = serialized.data;\n              var docRef = doc(firestore, path);\n              switch (type) {\n                case 'DELETE':\n                  tsx.delete(docRef);\n                  break;\n                case 'UPDATE':\n                  tsx.update(docRef, readableToObject(firestore, data));\n                  break;\n                case 'SET':\n                  var options = serialized.options;\n                  var setOptions = {};\n                  if ('merge' in options) {\n                    setOptions.merge = options.merge;\n                  } else if ('mergeFields' in options) {\n                    setOptions.mergeFields = options.mergeFields;\n                  }\n                  tsx.set(docRef, readableToObject(firestore, data), setOptions);\n                  break;\n              }\n            }\n          });\n          return function (_x2) {\n            return _ref11.apply(this, arguments);\n          };\n        }());\n        emitEvent('firestore_transaction_event', {\n          eventName: 'firestore_transaction_event',\n          body: {\n            type: 'complete'\n          },\n          appName: appName,\n          databaseId: databaseId,\n          listenerId: transactionId\n        });\n      } catch (e) {\n        emitEvent('firestore_transaction_event', {\n          eventName: 'firestore_transaction_event',\n          body: {\n            type: 'error',\n            error: getWebError(e)\n          },\n          appName: appName,\n          databaseId: databaseId,\n          listenerId: transactionId\n        });\n      }\n    }));\n  }\n};","map":{"version":3,"names":["setLogLevel","connectFirestoreEmulator","initializeFirestore","runTransaction","getApp","getFirestore","collection","collectionGroup","doc","getDoc","getDocs","getCount","getAggregate","count","average","sum","deleteDoc","setDoc","updateDoc","writeBatch","terminate","guard","getWebError","emitEvent","objectToWriteable","readableToObject","parseDocumentBatches","buildQuery","rejectWithCodeAndMessage","code","message","Promise","reject","documentSnapshotToObject","snapshot","exists","out","metadata","path","ref","data","querySnapshotToObject","source","excludesMetadataChanges","changes","documents","docs","map","emulatorForApp","firestoreInstances","appInstances","transactionHandler","transactionBuffer","getCachedAppInstance","appName","createFirestoreKey","databaseId","getCachedFirestoreInstance","firestoreKey","instance","host","port","_setLogLevel2","_asyncToGenerator","logLevel","_x","apply","arguments","loadBundle","clearPersistence","waitForPendingWrites","_waitForPendingWrites","disableNetwork","enableNetwork","addSnapshotsInSync","removeSnapshotsInSync","useEmulator","firestore","settings","namedQueryOnSnapshot","collectionOnSnapshot","collectionOffSnapshot","namedQueryGet","collectionCount","type","filters","orders","options","queryRef","query","aggregateQuery","aggregateQueries","aggregateSpec","i","length","aggregateType","field","key","result","response","collectionGet","getOptions","documentOnSnapshot","documentOffSnapshot","persistenceCacheIndexManager","documentGet","documentDelete","documentSet","setOptions","merge","mergeFields","documentUpdate","documentBatch","writes","batch","writesArray","parsed","delete","update","set","commit","transactionGetDocument","transactionId","docRef","tsx","get","transactionDispose","_appName","_databaseId","transactionApplyBuffer","commandBuffer","transactionBegin","_ref11","eventName","body","listenerId","getBuffer","buffer","resolve","interval","setInterval","clearInterval","serialized","_x2","e","error"],"sources":["C:/Users/mopym/crud-firebase-app/node_modules/@react-native-firebase/firestore/lib/web/RNFBFirestoreModule.js"],"sourcesContent":["import {\n  setLogLevel,\n  connectFirestoreEmulator,\n  initializeFirestore,\n  runTransaction,\n  getApp,\n  getFirestore,\n  collection,\n  collectionGroup,\n  doc,\n  getDoc,\n  getDocs,\n  getCount,\n  getAggregate,\n  count,\n  average,\n  sum,\n  deleteDoc,\n  setDoc,\n  updateDoc,\n  writeBatch,\n  terminate,\n} from '@react-native-firebase/app/lib/internal/web/firebaseFirestore';\nimport { guard, getWebError, emitEvent } from '@react-native-firebase/app/lib/internal/web/utils';\nimport { objectToWriteable, readableToObject, parseDocumentBatches } from './convert';\nimport { buildQuery } from './query';\n\nfunction rejectWithCodeAndMessage(code, message) {\n  return Promise.reject(\n    getWebError({\n      code,\n      message,\n    }),\n  );\n}\n\n// Converts a Firestore document snapshot to a plain object.\nfunction documentSnapshotToObject(snapshot) {\n  const exists = snapshot.exists();\n\n  const out = {\n    metadata: [false, false], // lite SDK doesn't return metadata\n    path: snapshot.ref.path,\n    exists,\n  };\n\n  if (exists) {\n    out.data = objectToWriteable(snapshot.data() || {});\n  }\n\n  return out;\n}\n\n// Converts a Firestore query snapshot to a plain object.\nfunction querySnapshotToObject(snapshot) {\n  return {\n    source: 'get',\n    excludesMetadataChanges: true, // lite SDK doesn't return metadata changes\n    changes: [],\n    metadata: [false, false], // lite SDK doesn't return metadata\n    documents: snapshot.docs.map(documentSnapshotToObject),\n  };\n}\n\nconst emulatorForApp = {};\nconst firestoreInstances = {};\nconst appInstances = {};\nconst transactionHandler = {};\nconst transactionBuffer = {};\n\nfunction getCachedAppInstance(appName) {\n  return (appInstances[appName] ??= getApp(appName));\n}\n\nfunction createFirestoreKey(appName, databaseId) {\n  return `${appName}:${databaseId}`;\n}\n\n// Returns a cached Firestore instance.\nfunction getCachedFirestoreInstance(appName, databaseId) {\n  const firestoreKey = createFirestoreKey(appName, databaseId);\n  let instance = firestoreInstances[firestoreKey];\n  if (!instance) {\n    instance = getFirestore(getCachedAppInstance(appName), databaseId);\n    if (emulatorForApp[firestoreKey]) {\n      connectFirestoreEmulator(\n        instance,\n        emulatorForApp[firestoreKey].host,\n        emulatorForApp[firestoreKey].port,\n      );\n    }\n    firestoreInstances[firestoreKey] = instance;\n  }\n  return instance;\n}\n\nexport default {\n  /**\n   * Sets the log level for Firestore.\n   * @param {string} logLevel - The log level.\n   */\n  async setLogLevel(logLevel) {\n    if (logLevel === 'debug' || logLevel === 'error') {\n      setLogLevel(logLevel);\n    } else {\n      setLogLevel('silent');\n    }\n  },\n\n  loadBundle() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  clearPersistence() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  /**\n   * Waits for all pending writes to be acknowledged by the backend.\n   * Noop in the lite SDK.\n   * @returns {Promise<null>} An empty promise.\n   */\n  async waitForPendingWrites() {\n    return null;\n  },\n\n  disableNetwork() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  enableNetwork() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  addSnapshotsInSync() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  removeSnapshotsInSync() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  /**\n   * Use the Firestore emulator.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} host - The emulator host.\n   * @param {number} port - The emulator port.\n   * @returns {Promise<null>} An empty promise.\n   */\n  useEmulator(appName, databaseId, host, port) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      connectFirestoreEmulator(firestore, host, port);\n      const firestoreKey = createFirestoreKey(appName, databaseId);\n      emulatorForApp[firestoreKey] = { host, port };\n    });\n  },\n\n  /**\n   * Initializes a Firestore instance with settings.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {object} settings - The Firestore settings.\n   * @returns {Promise<null>} An empty promise.\n   */\n  settings(appName, databaseId, settings) {\n    return guard(() => {\n      const instance = initializeFirestore(getCachedAppInstance(appName), settings, databaseId);\n      firestoreInstances[appName] = instance;\n    });\n  },\n\n  /**\n   * Terminates a Firestore instance.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @returns {Promise<null>} An empty promise.\n   */\n  terminate(appName, databaseId) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      await terminate(firestore);\n      return null;\n    });\n  },\n\n  // Collection\n  namedQueryOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  collectionOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  collectionOffSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  namedQueryGet() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  /**\n   * Get a collection count from Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The collection path.\n   * @param {string} type - The collection type (e.g. collectionGroup).\n   * @param {object[]} filters - The collection filters.\n   * @param {object[]} orders - The collection orders.\n   * @param {object} options - The collection options.\n   * @returns {Promise<object>} The collection count object.\n   */\n  collectionCount(appName, databaseId, path, type, filters, orders, options) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const queryRef =\n        type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      const query = buildQuery(queryRef, filters, orders, options);\n      const snapshot = await getCount(query);\n\n      return {\n        count: snapshot.data().count,\n      };\n    });\n  },\n\n  aggregateQuery(appName, databaseId, path, type, filters, orders, options, aggregateQueries) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const queryRef =\n        type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      const query = buildQuery(queryRef, filters, orders, options);\n      const aggregateSpec = {};\n\n      for (let i = 0; i < aggregateQueries.length; i++) {\n        const aggregateQuery = aggregateQueries[i];\n        const { aggregateType, field, key } = aggregateQuery;\n\n        switch (aggregateType) {\n          case 'count':\n            aggregateSpec[key] = count();\n            break;\n          case 'average':\n            aggregateSpec[key] = average(field);\n            break;\n          case 'sum':\n            aggregateSpec[key] = sum(field);\n            break;\n        }\n      }\n      const result = await getAggregate(query, aggregateSpec);\n\n      const data = result.data();\n      const response = {};\n      for (let i = 0; i < aggregateQueries.length; i++) {\n        const aggregateQuery = aggregateQueries[i];\n        const { key } = aggregateQuery;\n        response[key] = data[key];\n      }\n\n      return response;\n    });\n  },\n\n  /**\n   * Get a collection from Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The collection path.\n   * @param {string} type - The collection type (e.g. collectionGroup).\n   * @param {object[]} filters - The collection filters.\n   * @param {object[]} orders - The collection orders.\n   * @param {object} options - The collection options.\n   * @param {object} getOptions - The get options.\n   * @returns {Promise<object>} The collection object.\n   */\n  collectionGet(appName, databaseId, path, type, filters, orders, options, getOptions) {\n    if (getOptions && getOptions.source === 'cache') {\n      return rejectWithCodeAndMessage(\n        'unsupported',\n        'The source cache is not supported in the lite SDK.',\n      );\n    }\n\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const queryRef =\n        type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      const query = buildQuery(queryRef, filters, orders, options);\n      const snapshot = await getDocs(query);\n      return querySnapshotToObject(snapshot);\n    });\n  },\n\n  // Document\n  documentOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  documentOffSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  persistenceCacheIndexManager() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  /**\n   * Get a document from Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The document path.\n   * @param {object} getOptions - The get options.\n   * @returns {Promise<object>} The document object.\n   */\n  documentGet(appName, databaseId, path, getOptions) {\n    return guard(async () => {\n      if (getOptions && getOptions.source === 'cache') {\n        return rejectWithCodeAndMessage(\n          'unsupported',\n          'The source cache is not supported in the lite SDK.',\n        );\n      }\n\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const ref = doc(firestore, path);\n      const snapshot = await getDoc(ref);\n      return documentSnapshotToObject(snapshot);\n    });\n  },\n\n  /**\n   * Delete a document from Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The document path.\n   * @returns {Promise<null>} An empty promise.\n   */\n  documentDelete(appName, databaseId, path) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const ref = doc(firestore, path);\n      await deleteDoc(ref);\n      return null;\n    });\n  },\n\n  /**\n   * Set a document in Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The document path.\n   * @param {object} data - The document data.\n   * @param {object} options - The set options.\n   * @returns {Promise<null>} An empty promise.\n   */\n  documentSet(appName, databaseId, path, data, options) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const ref = doc(firestore, path);\n      const setOptions = {};\n      if ('merge' in options) {\n        setOptions.merge = options.merge;\n      } else if ('mergeFields' in options) {\n        setOptions.mergeFields = options.mergeFields;\n      }\n      await setDoc(ref, readableToObject(firestore, data), setOptions);\n    });\n  },\n\n  /**\n   * Update a document in Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The document path.\n   * @param {object} data - The document data.\n   * @returns {Promise<null>} An empty promise.\n   */\n  documentUpdate(appName, databaseId, path, data) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const ref = doc(firestore, path);\n      await updateDoc(ref, readableToObject(firestore, data));\n    });\n  },\n\n  /**\n   * Batch write documents in Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {object[]} writes - The document writes in write batches format.\n   */\n  documentBatch(appName, databaseId, writes) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const batch = writeBatch(firestore);\n      const writesArray = parseDocumentBatches(firestore, writes);\n\n      for (const parsed of writesArray) {\n        const { type, path } = parsed;\n        const ref = doc(firestore, path);\n\n        switch (type) {\n          case 'DELETE':\n            batch.delete(ref);\n            break;\n          case 'UPDATE':\n            batch.update(ref, parsed.data);\n            break;\n          case 'SET':\n            const options = parsed.options;\n            const setOptions = {};\n            if ('merge' in options) {\n              setOptions.merge = options.merge;\n            } else if ('mergeFields' in options) {\n              setOptions.mergeFields = options.mergeFields;\n            }\n            batch.set(ref, parsed.data, setOptions);\n            break;\n        }\n      }\n\n      await batch.commit();\n    });\n  },\n\n  /**\n   * Get a document from a Firestore transaction.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} transactionId - The transaction id.\n   * @param {string} path - The document path.\n   * @returns {Promise<object>} The document object.\n   */\n  transactionGetDocument(appName, databaseId, transactionId, path) {\n    if (!transactionHandler[transactionId]) {\n      return rejectWithCodeAndMessage(\n        'internal-error',\n        'An internal error occurred whilst attempting to find a native transaction by id.',\n      );\n    }\n\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const docRef = doc(firestore, path);\n      const tsx = transactionHandler[transactionId];\n      const snapshot = await tsx.get(docRef);\n      return documentSnapshotToObject(snapshot);\n    });\n  },\n\n  /**\n   * Dispose a transaction instance.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} transactionId - The transaction id.\n   */\n  transactionDispose(_appName, _databaseId, transactionId) {\n    // There's no abort method in the JS SDK, so we just remove the transaction handler.\n    delete transactionHandler[transactionId];\n  },\n\n  /**\n   * Applies a buffer of commands to a Firestore transaction.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} transactionId - The transaction id.\n   * @param {object[]} commandBuffer - The readable array of buffer commands.\n   */\n  transactionApplyBuffer(_appName, _databaseId, transactionId, commandBuffer) {\n    if (transactionHandler[transactionId]) {\n      transactionBuffer[transactionId] = commandBuffer;\n    }\n  },\n\n  /**\n   * Begins a Firestore transaction.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} transactionId - The transaction id.\n   * @returns {Promise<null>} An empty promise.\n   */\n  transactionBegin(appName, databaseId, transactionId) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n\n      try {\n        await runTransaction(firestore, async tsx => {\n          transactionHandler[transactionId] = tsx;\n\n          emitEvent('firestore_transaction_event', {\n            eventName: 'firestore_transaction_event',\n            body: { type: 'update' },\n            appName,\n            databaseId,\n            listenerId: transactionId,\n          });\n\n          function getBuffer() {\n            return transactionBuffer[transactionId];\n          }\n\n          // Wait for and get the stored buffer array for the transaction.\n          const buffer = await new Promise(resolve => {\n            const interval = setInterval(() => {\n              const buffer = getBuffer();\n              if (buffer) {\n                clearInterval(interval);\n                resolve(buffer);\n              }\n            }, 100);\n          });\n\n          for (const serialized of buffer) {\n            const { path, type, data } = serialized;\n            const docRef = doc(firestore, path);\n\n            switch (type) {\n              case 'DELETE':\n                tsx.delete(docRef);\n                break;\n              case 'UPDATE':\n                tsx.update(docRef, readableToObject(firestore, data));\n                break;\n              case 'SET':\n                const options = serialized.options;\n                const setOptions = {};\n                if ('merge' in options) {\n                  setOptions.merge = options.merge;\n                } else if ('mergeFields' in options) {\n                  setOptions.mergeFields = options.mergeFields;\n                }\n                tsx.set(docRef, readableToObject(firestore, data), setOptions);\n                break;\n            }\n          }\n        });\n\n        emitEvent('firestore_transaction_event', {\n          eventName: 'firestore_transaction_event',\n          body: { type: 'complete' },\n          appName,\n          databaseId,\n          listenerId: transactionId,\n        });\n      } catch (e) {\n        emitEvent('firestore_transaction_event', {\n          eventName: 'firestore_transaction_event',\n          body: { type: 'error', error: getWebError(e) },\n          appName,\n          databaseId,\n          listenerId: transactionId,\n        });\n      }\n    });\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}